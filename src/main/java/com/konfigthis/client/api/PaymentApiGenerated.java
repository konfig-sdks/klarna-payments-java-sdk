/*
 * Klarna Payments API V1
 * The payments API is used to create a session to offer Klarna's payment methods as part of your checkout. As soon as the purchase is completed the order should be read and handled using the [`Order Management API`](https://docs.klarna.com/api/ordermanagement).  **Note:** Examples provided in this section includes full payloads, including all supported fields , required and optionals. In order to implement a best in class request we recommend you don't include customer details when initiating a payment session. Refer to [Initiate a payment](https://docs.klarna.com/klarna-payments/integrate-with-klarna-payments/step-1-initiate-a-payment/) section for further details.  Read more on [Klarna payments](https://docs.klarna.com/klarna-payments/).
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.Address;
import com.konfigthis.client.model.Attachment;
import com.konfigthis.client.model.CreateOrderRequest;
import com.konfigthis.client.model.Customer;
import com.konfigthis.client.model.CustomerTokenCreationRequest;
import com.konfigthis.client.model.CustomerTokenCreationResponse;
import com.konfigthis.client.model.MerchantSession;
import com.konfigthis.client.model.MerchantUrls;
import java.time.OffsetDateTime;
import com.konfigthis.client.model.Options;
import com.konfigthis.client.model.Order;
import com.konfigthis.client.model.OrderLine;
import com.konfigthis.client.model.PaymentMethodCategory;
import com.konfigthis.client.model.Session;
import com.konfigthis.client.model.SessionCreate;
import com.konfigthis.client.model.SessionRead;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class PaymentApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public PaymentApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public PaymentApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call cancelAuthorizationCall(String authorizationToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/payments/v1/authorizations/{authorizationToken}"
            .replace("{" + "authorizationToken" + "}", localVarApiClient.escapeString(authorizationToken.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelAuthorizationValidateBeforeCall(String authorizationToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorizationToken' is set
        if (authorizationToken == null) {
            throw new ApiException("Missing the required parameter 'authorizationToken' when calling cancelAuthorization(Async)");
        }

        return cancelAuthorizationCall(authorizationToken, _callback);

    }


    private ApiResponse<Void> cancelAuthorizationWithHttpInfo(String authorizationToken) throws ApiException {
        okhttp3.Call localVarCall = cancelAuthorizationValidateBeforeCall(authorizationToken, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call cancelAuthorizationAsync(String authorizationToken, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelAuthorizationValidateBeforeCall(authorizationToken, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class CancelAuthorizationRequestBuilder {
        private final String authorizationToken;

        private CancelAuthorizationRequestBuilder(String authorizationToken) {
            this.authorizationToken = authorizationToken;
        }

        /**
         * Build call for cancelAuthorization
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The authorization was cancelled successfully. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return cancelAuthorizationCall(authorizationToken, _callback);
        }


        /**
         * Execute cancelAuthorization request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The authorization was cancelled successfully. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            cancelAuthorizationWithHttpInfo(authorizationToken);
        }

        /**
         * Execute cancelAuthorization request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The authorization was cancelled successfully. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return cancelAuthorizationWithHttpInfo(authorizationToken);
        }

        /**
         * Execute cancelAuthorization request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The authorization was cancelled successfully. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return cancelAuthorizationAsync(authorizationToken, _callback);
        }
    }

    /**
     * Cancel an authorization
     * Use this API call to cancel/release an authorization. If the &#x60;authorization_token&#x60; received during a Klarna Payments won’t be used to place an order immediately you could release the authorization. Read more on **[Cancel an existing authorization](https://docs.klarna.com/klarna-payments/other-actions/cancel-an-authorization/)**.
     * @param authorizationToken  (required)
     * @return CancelAuthorizationRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The authorization was cancelled successfully. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public CancelAuthorizationRequestBuilder cancelAuthorization(String authorizationToken) throws IllegalArgumentException {
        if (authorizationToken == null) throw new IllegalArgumentException("\"authorizationToken\" is required but got null");
            

        return new CancelAuthorizationRequestBuilder(authorizationToken);
    }
    private okhttp3.Call createOrderCall(String authorizationToken, CreateOrderRequest createOrderRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createOrderRequest;

        // create path and map variables
        String localVarPath = "/payments/v1/authorizations/{authorizationToken}/order"
            .replace("{" + "authorizationToken" + "}", localVarApiClient.escapeString(authorizationToken.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOrderValidateBeforeCall(String authorizationToken, CreateOrderRequest createOrderRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorizationToken' is set
        if (authorizationToken == null) {
            throw new ApiException("Missing the required parameter 'authorizationToken' when calling createOrder(Async)");
        }

        return createOrderCall(authorizationToken, createOrderRequest, _callback);

    }


    private ApiResponse<Order> createOrderWithHttpInfo(String authorizationToken, CreateOrderRequest createOrderRequest) throws ApiException {
        okhttp3.Call localVarCall = createOrderValidateBeforeCall(authorizationToken, createOrderRequest, null);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createOrderAsync(String authorizationToken, CreateOrderRequest createOrderRequest, final ApiCallback<Order> _callback) throws ApiException {

        okhttp3.Call localVarCall = createOrderValidateBeforeCall(authorizationToken, createOrderRequest, _callback);
        Type localVarReturnType = new TypeToken<Order>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateOrderRequestBuilder {
        private final Long orderAmount;
        private final List<OrderLine> orderLines;
        private final String purchaseCountry;
        private final String purchaseCurrency;
        private final String authorizationToken;
        private String authorizationToken;
        private Boolean autoCapture;
        private Address billingAddress;
        private List<String> customPaymentMethodIds;
        private Customer customer;
        private String locale;
        private String merchantData;
        private String merchantReference1;
        private String merchantReference2;
        private MerchantUrls merchantUrls;
        private Long orderTaxAmount;
        private Set<PaymentMethodCategory> paymentMethodCategories;
        private Address shippingAddress;
        private String status;

        private CreateOrderRequestBuilder(Long orderAmount, List<OrderLine> orderLines, String purchaseCountry, String purchaseCurrency, String authorizationToken) {
            this.orderAmount = orderAmount;
            this.orderLines = orderLines;
            this.purchaseCountry = purchaseCountry;
            this.purchaseCurrency = purchaseCurrency;
            this.authorizationToken = authorizationToken;
        }

        /**
         * Set authorizationToken
         * @param authorizationToken Authorization token. (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder authorizationToken(String authorizationToken) {
            this.authorizationToken = authorizationToken;
            return this;
        }
        
        /**
         * Set autoCapture
         * @param autoCapture Allow merchant to trigger auto capturing. (optional, default to false)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder autoCapture(Boolean autoCapture) {
            this.autoCapture = autoCapture;
            return this;
        }
        
        /**
         * Set billingAddress
         * @param billingAddress  (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder billingAddress(Address billingAddress) {
            this.billingAddress = billingAddress;
            return this;
        }
        
        /**
         * Set customPaymentMethodIds
         * @param customPaymentMethodIds Promo codes - The array could be used to define which of the configured payment options within a payment category (pay_later, pay_over_time, etc.) should be shown for this purchase. Discuss with the delivery manager to know about the promo codes that will be configured for your account. The feature could also be used to provide promotional offers to specific customers (eg: 0% financing). Please be informed that the usage of this feature can have commercial implications.  (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder customPaymentMethodIds(List<String> customPaymentMethodIds) {
            this.customPaymentMethodIds = customPaymentMethodIds;
            return this;
        }
        
        /**
         * Set customer
         * @param customer  (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder customer(Customer customer) {
            this.customer = customer;
            return this;
        }
        
        /**
         * Set locale
         * @param locale Used to define the language and region of the customer. The locale follows the format of [RFC 1766](https://datatracker.ietf.org/doc/rfc1766/), meaning its value consists of language-country. Read more on **[Supported Locals and Currencies](https://docs.klarna.com/klarna-payments/in-depth-knowledge/puchase-countries-currencies-locales/)**. (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder locale(String locale) {
            this.locale = locale;
            return this;
        }
        
        /**
         * Set merchantData
         * @param merchantData Pass through field to send any information about the order to be used later for reference while retrieving the order details (max 6000 characters) (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder merchantData(String merchantData) {
            this.merchantData = merchantData;
            return this;
        }
        
        /**
         * Set merchantReference1
         * @param merchantReference1 Used for storing merchant&#39;s internal order number or other reference. (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder merchantReference1(String merchantReference1) {
            this.merchantReference1 = merchantReference1;
            return this;
        }
        
        /**
         * Set merchantReference2
         * @param merchantReference2 Used for storing merchant&#39;s internal order number or other reference. The value is available in the settlement files. (max 255 characters). (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder merchantReference2(String merchantReference2) {
            this.merchantReference2 = merchantReference2;
            return this;
        }
        
        /**
         * Set merchantUrls
         * @param merchantUrls  (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder merchantUrls(MerchantUrls merchantUrls) {
            this.merchantUrls = merchantUrls;
            return this;
        }
        
        /**
         * Set orderTaxAmount
         * @param orderTaxAmount Total tax amount of the order. The value should be in non-negative minor units. Eg: 25 Euros should be 2500. (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder orderTaxAmount(Long orderTaxAmount) {
            this.orderTaxAmount = orderTaxAmount;
            return this;
        }
        
        /**
         * Set paymentMethodCategories
         * @param paymentMethodCategories Available payment method categories (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder paymentMethodCategories(Set<PaymentMethodCategory> paymentMethodCategories) {
            this.paymentMethodCategories = paymentMethodCategories;
            return this;
        }
        
        /**
         * Set shippingAddress
         * @param shippingAddress  (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder shippingAddress(Address shippingAddress) {
            this.shippingAddress = shippingAddress;
            return this;
        }
        
        /**
         * Set status
         * @param status The current status of the session. Possible values: &#39;complete&#39;, &#39;incomplete&#39; where &#39;complete&#39; is set when the order has been placed. (optional)
         * @return CreateOrderRequestBuilder
         */
        public CreateOrderRequestBuilder status(String status) {
            this.status = status;
            return this;
        }
        
        /**
         * Build call for createOrder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Order was successfully created. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to create an order with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            CreateOrderRequest createOrderRequest = buildBodyParams();
            return createOrderCall(authorizationToken, createOrderRequest, _callback);
        }

        private CreateOrderRequest buildBodyParams() {
            CreateOrderRequest createOrderRequest = new CreateOrderRequest();
            createOrderRequest.authorizationToken(this.authorizationToken);
            createOrderRequest.autoCapture(this.autoCapture);
            createOrderRequest.billingAddress(this.billingAddress);
            createOrderRequest.customPaymentMethodIds(this.customPaymentMethodIds);
            createOrderRequest.customer(this.customer);
            createOrderRequest.locale(this.locale);
            createOrderRequest.merchantData(this.merchantData);
            createOrderRequest.merchantReference1(this.merchantReference1);
            createOrderRequest.merchantReference2(this.merchantReference2);
            createOrderRequest.merchantUrls(this.merchantUrls);
            createOrderRequest.orderAmount(this.orderAmount);
            createOrderRequest.orderLines(this.orderLines);
            createOrderRequest.orderTaxAmount(this.orderTaxAmount);
            createOrderRequest.paymentMethodCategories(this.paymentMethodCategories);
            createOrderRequest.purchaseCountry(this.purchaseCountry);
            createOrderRequest.purchaseCurrency(this.purchaseCurrency);
            createOrderRequest.shippingAddress(this.shippingAddress);
            if (this.status != null)
            createOrderRequest.status(CreateOrderRequest.StatusEnum.fromValue(this.status));
            return createOrderRequest;
        }

        /**
         * Execute createOrder request
         * @return Order
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Order was successfully created. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to create an order with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
         </table>
         */
        public Order execute() throws ApiException {
            CreateOrderRequest createOrderRequest = buildBodyParams();
            ApiResponse<Order> localVarResp = createOrderWithHttpInfo(authorizationToken, createOrderRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createOrder request with HTTP info returned
         * @return ApiResponse&lt;Order&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Order was successfully created. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to create an order with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Order> executeWithHttpInfo() throws ApiException {
            CreateOrderRequest createOrderRequest = buildBodyParams();
            return createOrderWithHttpInfo(authorizationToken, createOrderRequest);
        }

        /**
         * Execute createOrder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Order was successfully created. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to create an order with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Order> _callback) throws ApiException {
            CreateOrderRequest createOrderRequest = buildBodyParams();
            return createOrderAsync(authorizationToken, createOrderRequest, _callback);
        }
    }

    /**
     * Create an order
     * Use this API call to create a new order. Placing an order towards Klarna means that the Klarna Payments session will be closed and that an order will be created in Klarna&#39;s system.&lt;br/&gt;When you have received the &#x60;authorization_token&#x60; for a successful authorization you can place the order. Among the other order details in this request, you include a URL to the confirmation page for the customer.&lt;br/&gt;When the Order has been successfully placed at Klarna, you need to handle it either through the Merchant Portal or using [Klarna’s Order Management API](https://docs.klarna.com/api/payments/). Read more on **[Create a new order](https://docs.klarna.com/klarna-payments/integrate-with-klarna-payments/step-3-create-an-order/)**.
     * @param authorizationToken  (required)
     * @return CreateOrderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Order was successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> We were unable to create an order with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
     </table>
     */
    public CreateOrderRequestBuilder createOrder(Long orderAmount, List<OrderLine> orderLines, String purchaseCountry, String purchaseCurrency, String authorizationToken) throws IllegalArgumentException {
        if (orderAmount == null) throw new IllegalArgumentException("\"orderAmount\" is required but got null");
        if (orderLines == null) throw new IllegalArgumentException("\"orderLines\" is required but got null");
        if (purchaseCountry == null) throw new IllegalArgumentException("\"purchaseCountry\" is required but got null");
            

        if (purchaseCurrency == null) throw new IllegalArgumentException("\"purchaseCurrency\" is required but got null");
            

        if (authorizationToken == null) throw new IllegalArgumentException("\"authorizationToken\" is required but got null");
            

        return new CreateOrderRequestBuilder(orderAmount, orderLines, purchaseCountry, purchaseCurrency, authorizationToken);
    }
    private okhttp3.Call createSessionCall(SessionCreate sessionCreate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = sessionCreate;

        // create path and map variables
        String localVarPath = "/payments/v1/sessions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSessionValidateBeforeCall(SessionCreate sessionCreate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sessionCreate' is set
        if (sessionCreate == null) {
            throw new ApiException("Missing the required parameter 'sessionCreate' when calling createSession(Async)");
        }

        return createSessionCall(sessionCreate, _callback);

    }


    private ApiResponse<MerchantSession> createSessionWithHttpInfo(SessionCreate sessionCreate) throws ApiException {
        okhttp3.Call localVarCall = createSessionValidateBeforeCall(sessionCreate, null);
        Type localVarReturnType = new TypeToken<MerchantSession>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createSessionAsync(SessionCreate sessionCreate, final ApiCallback<MerchantSession> _callback) throws ApiException {

        okhttp3.Call localVarCall = createSessionValidateBeforeCall(sessionCreate, _callback);
        Type localVarReturnType = new TypeToken<MerchantSession>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateSessionRequestBuilder {
        private final Long orderAmount;
        private final List<OrderLine> orderLines;
        private final String purchaseCountry;
        private final String purchaseCurrency;
        private String acquiringChannel;
        private Attachment attachment;
        private String authorizationToken;
        private Address billingAddress;
        private String clientToken;
        private List<String> customPaymentMethodIds;
        private Customer customer;
        private String design;
        private OffsetDateTime expiresAt;
        private String locale;
        private String merchantData;
        private String merchantReference1;
        private String merchantReference2;
        private MerchantUrls merchantUrls;
        private Options options;
        private Long orderTaxAmount;
        private Set<PaymentMethodCategory> paymentMethodCategories;
        private Address shippingAddress;
        private String status;
        private String intent;

        private CreateSessionRequestBuilder(Long orderAmount, List<OrderLine> orderLines, String purchaseCountry, String purchaseCurrency) {
            this.orderAmount = orderAmount;
            this.orderLines = orderLines;
            this.purchaseCountry = purchaseCountry;
            this.purchaseCurrency = purchaseCurrency;
        }

        /**
         * Set acquiringChannel
         * @param acquiringChannel The acquiring channel in which the session takes place. Ecommerce is default unless specified. Any other values should be defined in the agreement. (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder acquiringChannel(String acquiringChannel) {
            this.acquiringChannel = acquiringChannel;
            return this;
        }
        
        /**
         * Set attachment
         * @param attachment  (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder attachment(Attachment attachment) {
            this.attachment = attachment;
            return this;
        }
        
        /**
         * Set authorizationToken
         * @param authorizationToken Authorization token. (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder authorizationToken(String authorizationToken) {
            this.authorizationToken = authorizationToken;
            return this;
        }
        
        /**
         * Set billingAddress
         * @param billingAddress  (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder billingAddress(Address billingAddress) {
            this.billingAddress = billingAddress;
            return this;
        }
        
        /**
         * Set clientToken
         * @param clientToken Token to be passed to the JS client (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder clientToken(String clientToken) {
            this.clientToken = clientToken;
            return this;
        }
        
        /**
         * Set customPaymentMethodIds
         * @param customPaymentMethodIds Promo codes - The array could be used to define which of the configured payment options within a payment category (pay_later, pay_over_time, etc.) should be shown for this purchase. Discuss with the delivery manager to know about the promo codes that will be configured for your account. The feature could also be used to provide promotional offers to specific customers (eg: 0% financing). Please be informed that the usage of this feature can have commercial implications.  (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder customPaymentMethodIds(List<String> customPaymentMethodIds) {
            this.customPaymentMethodIds = customPaymentMethodIds;
            return this;
        }
        
        /**
         * Set customer
         * @param customer  (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder customer(Customer customer) {
            this.customer = customer;
            return this;
        }
        
        /**
         * Set design
         * @param design Design package to use in the session. This can only by used if a custom design has been implemented for Klarna Payments and agreed upon in the agreement. It might have a financial impact. Delivery manager will provide the value for the parameter. (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder design(String design) {
            this.design = design;
            return this;
        }
        
        /**
         * Set expiresAt
         * @param expiresAt Session expiration date (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder expiresAt(OffsetDateTime expiresAt) {
            this.expiresAt = expiresAt;
            return this;
        }
        
        /**
         * Set locale
         * @param locale Used to define the language and region of the customer. The locale follows the format of [RFC 1766](https://datatracker.ietf.org/doc/rfc1766/), meaning its value consists of language-country. Default value is \\\&quot;en-US\\\&quot;. Read more on **[Supported Locals and Currencies](https://docs.klarna.com/klarna-payments/in-depth-knowledge/puchase-countries-currencies-locales/)**. (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder locale(String locale) {
            this.locale = locale;
            return this;
        }
        
        /**
         * Set merchantData
         * @param merchantData Pass through field to send any information about the order to be used later for reference while retrieving the order details (max 6000 characters) (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder merchantData(String merchantData) {
            this.merchantData = merchantData;
            return this;
        }
        
        /**
         * Set merchantReference1
         * @param merchantReference1 Used for storing merchant&#39;s internal order number or other reference. (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder merchantReference1(String merchantReference1) {
            this.merchantReference1 = merchantReference1;
            return this;
        }
        
        /**
         * Set merchantReference2
         * @param merchantReference2 Used for storing merchant&#39;s internal order number or other reference. The value is available in the settlement files. (max 255 characters). (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder merchantReference2(String merchantReference2) {
            this.merchantReference2 = merchantReference2;
            return this;
        }
        
        /**
         * Set merchantUrls
         * @param merchantUrls  (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder merchantUrls(MerchantUrls merchantUrls) {
            this.merchantUrls = merchantUrls;
            return this;
        }
        
        /**
         * Set options
         * @param options  (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder options(Options options) {
            this.options = options;
            return this;
        }
        
        /**
         * Set orderTaxAmount
         * @param orderTaxAmount Total tax amount of the order. The value should be in non-negative minor units. Eg: 25 Euros should be 2500. (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder orderTaxAmount(Long orderTaxAmount) {
            this.orderTaxAmount = orderTaxAmount;
            return this;
        }
        
        /**
         * Set paymentMethodCategories
         * @param paymentMethodCategories Available payment method categories (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder paymentMethodCategories(Set<PaymentMethodCategory> paymentMethodCategories) {
            this.paymentMethodCategories = paymentMethodCategories;
            return this;
        }
        
        /**
         * Set shippingAddress
         * @param shippingAddress  (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder shippingAddress(Address shippingAddress) {
            this.shippingAddress = shippingAddress;
            return this;
        }
        
        /**
         * Set status
         * @param status The current status of the session. Possible values: &#39;complete&#39;, &#39;incomplete&#39; where &#39;complete&#39; is set when the order has been placed. (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder status(String status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set intent
         * @param intent Intent for the session. The field is designed to let partners inform Klarna of the purpose of the customer’s session. (optional)
         * @return CreateSessionRequestBuilder
         */
        public CreateSessionRequestBuilder intent(String intent) {
            this.intent = intent;
            return this;
        }
        
        /**
         * Build call for createSession
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to create a session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SessionCreate sessionCreate = buildBodyParams();
            return createSessionCall(sessionCreate, _callback);
        }

        private SessionCreate buildBodyParams() {
            SessionCreate sessionCreate = new SessionCreate();
            if (this.acquiringChannel != null)
            sessionCreate.acquiringChannel(SessionCreate.AcquiringChannelEnum.fromValue(this.acquiringChannel));
            sessionCreate.attachment(this.attachment);
            sessionCreate.authorizationToken(this.authorizationToken);
            sessionCreate.billingAddress(this.billingAddress);
            sessionCreate.clientToken(this.clientToken);
            sessionCreate.customPaymentMethodIds(this.customPaymentMethodIds);
            sessionCreate.customer(this.customer);
            sessionCreate.design(this.design);
            sessionCreate.expiresAt(this.expiresAt);
            sessionCreate.locale(this.locale);
            sessionCreate.merchantData(this.merchantData);
            sessionCreate.merchantReference1(this.merchantReference1);
            sessionCreate.merchantReference2(this.merchantReference2);
            sessionCreate.merchantUrls(this.merchantUrls);
            sessionCreate.options(this.options);
            sessionCreate.orderAmount(this.orderAmount);
            sessionCreate.orderLines(this.orderLines);
            sessionCreate.orderTaxAmount(this.orderTaxAmount);
            sessionCreate.paymentMethodCategories(this.paymentMethodCategories);
            sessionCreate.purchaseCountry(this.purchaseCountry);
            sessionCreate.purchaseCurrency(this.purchaseCurrency);
            sessionCreate.shippingAddress(this.shippingAddress);
            if (this.status != null)
            sessionCreate.status(SessionCreate.StatusEnum.fromValue(this.status));
            if (this.intent != null)
            sessionCreate.intent(SessionCreate.IntentEnum.fromValue(this.intent));
            return sessionCreate;
        }

        /**
         * Execute createSession request
         * @return MerchantSession
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to create a session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
         </table>
         */
        public MerchantSession execute() throws ApiException {
            SessionCreate sessionCreate = buildBodyParams();
            ApiResponse<MerchantSession> localVarResp = createSessionWithHttpInfo(sessionCreate);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createSession request with HTTP info returned
         * @return ApiResponse&lt;MerchantSession&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to create a session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MerchantSession> executeWithHttpInfo() throws ApiException {
            SessionCreate sessionCreate = buildBodyParams();
            return createSessionWithHttpInfo(sessionCreate);
        }

        /**
         * Execute createSession request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to create a session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MerchantSession> _callback) throws ApiException {
            SessionCreate sessionCreate = buildBodyParams();
            return createSessionAsync(sessionCreate, _callback);
        }
    }

    /**
     * Create a session
     * Use this API call to create a Klarna Payments session.&lt;br/&gt;When a session is created you will receive the available &#x60;payment_method_categories&#x60; for the session, a &#x60;session_id&#x60; and a &#x60;client_token&#x60;. The &#x60;session_id&#x60; can be used to read or update the session using the REST API. The &#x60;client_token&#x60; should be passed to the browser. Read more on **[Create a new payment session](https://docs.klarna.com/klarna-payments/integrate-with-klarna-payments/step-1-initiate-a-payment/)**.
     * @param sessionCreate session_request (required)
     * @return CreateSessionRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> We were unable to create a session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
     </table>
     */
    public CreateSessionRequestBuilder createSession(Long orderAmount, List<OrderLine> orderLines, String purchaseCountry, String purchaseCurrency) throws IllegalArgumentException {
        if (orderAmount == null) throw new IllegalArgumentException("\"orderAmount\" is required but got null");
        if (orderLines == null) throw new IllegalArgumentException("\"orderLines\" is required but got null");
        if (purchaseCountry == null) throw new IllegalArgumentException("\"purchaseCountry\" is required but got null");
            

        if (purchaseCurrency == null) throw new IllegalArgumentException("\"purchaseCurrency\" is required but got null");
            

        return new CreateSessionRequestBuilder(orderAmount, orderLines, purchaseCountry, purchaseCurrency);
    }
    private okhttp3.Call generateCustomerTokenCall(String authorizationToken, CustomerTokenCreationRequest customerTokenCreationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = customerTokenCreationRequest;

        // create path and map variables
        String localVarPath = "/payments/v1/authorizations/{authorizationToken}/customer-token"
            .replace("{" + "authorizationToken" + "}", localVarApiClient.escapeString(authorizationToken.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call generateCustomerTokenValidateBeforeCall(String authorizationToken, CustomerTokenCreationRequest customerTokenCreationRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorizationToken' is set
        if (authorizationToken == null) {
            throw new ApiException("Missing the required parameter 'authorizationToken' when calling generateCustomerToken(Async)");
        }

        return generateCustomerTokenCall(authorizationToken, customerTokenCreationRequest, _callback);

    }


    private ApiResponse<CustomerTokenCreationResponse> generateCustomerTokenWithHttpInfo(String authorizationToken, CustomerTokenCreationRequest customerTokenCreationRequest) throws ApiException {
        okhttp3.Call localVarCall = generateCustomerTokenValidateBeforeCall(authorizationToken, customerTokenCreationRequest, null);
        Type localVarReturnType = new TypeToken<CustomerTokenCreationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call generateCustomerTokenAsync(String authorizationToken, CustomerTokenCreationRequest customerTokenCreationRequest, final ApiCallback<CustomerTokenCreationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = generateCustomerTokenValidateBeforeCall(authorizationToken, customerTokenCreationRequest, _callback);
        Type localVarReturnType = new TypeToken<CustomerTokenCreationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GenerateCustomerTokenRequestBuilder {
        private final String description;
        private final String intendedUse;
        private final String locale;
        private final String purchaseCountry;
        private final String purchaseCurrency;
        private final String authorizationToken;
        private Address billingAddress;
        private Customer customer;

        private GenerateCustomerTokenRequestBuilder(String description, String intendedUse, String locale, String purchaseCountry, String purchaseCurrency, String authorizationToken) {
            this.description = description;
            this.intendedUse = intendedUse;
            this.locale = locale;
            this.purchaseCountry = purchaseCountry;
            this.purchaseCurrency = purchaseCurrency;
            this.authorizationToken = authorizationToken;
        }

        /**
         * Set billingAddress
         * @param billingAddress  (optional)
         * @return GenerateCustomerTokenRequestBuilder
         */
        public GenerateCustomerTokenRequestBuilder billingAddress(Address billingAddress) {
            this.billingAddress = billingAddress;
            return this;
        }
        
        /**
         * Set customer
         * @param customer  (optional)
         * @return GenerateCustomerTokenRequestBuilder
         */
        public GenerateCustomerTokenRequestBuilder customer(Customer customer) {
            this.customer = customer;
            return this;
        }
        
        /**
         * Build call for generateCustomerToken
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Token was successfully created. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            CustomerTokenCreationRequest customerTokenCreationRequest = buildBodyParams();
            return generateCustomerTokenCall(authorizationToken, customerTokenCreationRequest, _callback);
        }

        private CustomerTokenCreationRequest buildBodyParams() {
            CustomerTokenCreationRequest customerTokenCreationRequest = new CustomerTokenCreationRequest();
            customerTokenCreationRequest.description(this.description);
            customerTokenCreationRequest.billingAddress(this.billingAddress);
            customerTokenCreationRequest.customer(this.customer);
            if (this.intendedUse != null)
            customerTokenCreationRequest.intendedUse(CustomerTokenCreationRequest.IntendedUseEnum.fromValue(this.intendedUse));
            customerTokenCreationRequest.locale(this.locale);
            customerTokenCreationRequest.purchaseCountry(this.purchaseCountry);
            customerTokenCreationRequest.purchaseCurrency(this.purchaseCurrency);
            return customerTokenCreationRequest;
        }

        /**
         * Execute generateCustomerToken request
         * @return CustomerTokenCreationResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Token was successfully created. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
         </table>
         */
        public CustomerTokenCreationResponse execute() throws ApiException {
            CustomerTokenCreationRequest customerTokenCreationRequest = buildBodyParams();
            ApiResponse<CustomerTokenCreationResponse> localVarResp = generateCustomerTokenWithHttpInfo(authorizationToken, customerTokenCreationRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute generateCustomerToken request with HTTP info returned
         * @return ApiResponse&lt;CustomerTokenCreationResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Token was successfully created. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<CustomerTokenCreationResponse> executeWithHttpInfo() throws ApiException {
            CustomerTokenCreationRequest customerTokenCreationRequest = buildBodyParams();
            return generateCustomerTokenWithHttpInfo(authorizationToken, customerTokenCreationRequest);
        }

        /**
         * Execute generateCustomerToken request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Token was successfully created. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<CustomerTokenCreationResponse> _callback) throws ApiException {
            CustomerTokenCreationRequest customerTokenCreationRequest = buildBodyParams();
            return generateCustomerTokenAsync(authorizationToken, customerTokenCreationRequest, _callback);
        }
    }

    /**
     * Generate a consumer token
     * Use this API call to create a Klarna Customer Token.&lt;br/&gt;After having obtained an &#x60;authorization_token&#x60; for a successful authorization, this can be used to create a purchase token instead of placing the order. Creating a Klarna Customer Token results in Klarna storing customer and payment method details. Read more on **[Generate a consumer token](https://docs.klarna.com/klarna-payments/in-depth-knowledge/customer-token/)**.
     * @param authorizationToken  (required)
     * @return GenerateCustomerTokenRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Token was successfully created. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The authorization does not exist. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> The data in the request does not match the session for the authorization. </td><td>  -  </td></tr>
     </table>
     */
    public GenerateCustomerTokenRequestBuilder generateCustomerToken(String description, String intendedUse, String locale, String purchaseCountry, String purchaseCurrency, String authorizationToken) throws IllegalArgumentException {
        if (description == null) throw new IllegalArgumentException("\"description\" is required but got null");
            if (description != null && description.length() < 1) {
              throw new IllegalArgumentException("Invalid value for description. Length must be greater than or equal to 1.");
            }

        if (intendedUse == null) throw new IllegalArgumentException("\"intendedUse\" is required but got null");
            

        if (locale == null) throw new IllegalArgumentException("\"locale\" is required but got null");
            

        if (purchaseCountry == null) throw new IllegalArgumentException("\"purchaseCountry\" is required but got null");
            

        if (purchaseCurrency == null) throw new IllegalArgumentException("\"purchaseCurrency\" is required but got null");
            

        if (authorizationToken == null) throw new IllegalArgumentException("\"authorizationToken\" is required but got null");
            

        return new GenerateCustomerTokenRequestBuilder(description, intendedUse, locale, purchaseCountry, purchaseCurrency, authorizationToken);
    }
    private okhttp3.Call getSessionDetailsCall(String sessionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/payments/v1/sessions/{session_id}"
            .replace("{" + "session_id" + "}", localVarApiClient.escapeString(sessionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSessionDetailsValidateBeforeCall(String sessionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sessionId' is set
        if (sessionId == null) {
            throw new ApiException("Missing the required parameter 'sessionId' when calling getSessionDetails(Async)");
        }

        return getSessionDetailsCall(sessionId, _callback);

    }


    private ApiResponse<SessionRead> getSessionDetailsWithHttpInfo(String sessionId) throws ApiException {
        okhttp3.Call localVarCall = getSessionDetailsValidateBeforeCall(sessionId, null);
        Type localVarReturnType = new TypeToken<SessionRead>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getSessionDetailsAsync(String sessionId, final ApiCallback<SessionRead> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSessionDetailsValidateBeforeCall(sessionId, _callback);
        Type localVarReturnType = new TypeToken<SessionRead>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetSessionDetailsRequestBuilder {
        private final String sessionId;

        private GetSessionDetailsRequestBuilder(String sessionId) {
            this.sessionId = sessionId;
        }

        /**
         * Build call for getSessionDetails
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getSessionDetailsCall(sessionId, _callback);
        }


        /**
         * Execute getSessionDetails request
         * @return SessionRead
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public SessionRead execute() throws ApiException {
            ApiResponse<SessionRead> localVarResp = getSessionDetailsWithHttpInfo(sessionId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getSessionDetails request with HTTP info returned
         * @return ApiResponse&lt;SessionRead&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SessionRead> executeWithHttpInfo() throws ApiException {
            return getSessionDetailsWithHttpInfo(sessionId);
        }

        /**
         * Execute getSessionDetails request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SessionRead> _callback) throws ApiException {
            return getSessionDetailsAsync(sessionId, _callback);
        }
    }

    /**
     * Get details about a session
     * Use this API call to get a Klarna Payments session. You can read the Klarna Payments session at any time after it has been created, to get information about it. This will return all data that has been collected during the session. Read more on **[Read an existing payment session](https://docs.klarna.com/klarna-payments/other-actions/check-the-details-of-a-payment-session/)**.
     * @param sessionId session_id (required)
     * @return GetSessionDetailsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public GetSessionDetailsRequestBuilder getSessionDetails(String sessionId) throws IllegalArgumentException {
        if (sessionId == null) throw new IllegalArgumentException("\"sessionId\" is required but got null");
            

        return new GetSessionDetailsRequestBuilder(sessionId);
    }
    private okhttp3.Call updateSessionDetailsCall(String sessionId, Session session, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = session;

        // create path and map variables
        String localVarPath = "/payments/v1/sessions/{session_id}"
            .replace("{" + "session_id" + "}", localVarApiClient.escapeString(sessionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSessionDetailsValidateBeforeCall(String sessionId, Session session, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sessionId' is set
        if (sessionId == null) {
            throw new ApiException("Missing the required parameter 'sessionId' when calling updateSessionDetails(Async)");
        }

        // verify the required parameter 'session' is set
        if (session == null) {
            throw new ApiException("Missing the required parameter 'session' when calling updateSessionDetails(Async)");
        }

        return updateSessionDetailsCall(sessionId, session, _callback);

    }


    private ApiResponse<Void> updateSessionDetailsWithHttpInfo(String sessionId, Session session) throws ApiException {
        okhttp3.Call localVarCall = updateSessionDetailsValidateBeforeCall(sessionId, session, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call updateSessionDetailsAsync(String sessionId, Session session, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateSessionDetailsValidateBeforeCall(sessionId, session, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class UpdateSessionDetailsRequestBuilder {
        private final String sessionId;
        private String acquiringChannel;
        private Attachment attachment;
        private String authorizationToken;
        private Address billingAddress;
        private String clientToken;
        private List<String> customPaymentMethodIds;
        private Customer customer;
        private String design;
        private OffsetDateTime expiresAt;
        private String locale;
        private String merchantData;
        private String merchantReference1;
        private String merchantReference2;
        private MerchantUrls merchantUrls;
        private Options options;
        private Long orderAmount;
        private List<OrderLine> orderLines;
        private Long orderTaxAmount;
        private Set<PaymentMethodCategory> paymentMethodCategories;
        private String purchaseCountry;
        private String purchaseCurrency;
        private Address shippingAddress;
        private String status;
        private String intent;

        private UpdateSessionDetailsRequestBuilder(String sessionId) {
            this.sessionId = sessionId;
        }

        /**
         * Set acquiringChannel
         * @param acquiringChannel The acquiring channel in which the session takes place. Ecommerce is default unless specified. Any other values should be defined in the agreement. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder acquiringChannel(String acquiringChannel) {
            this.acquiringChannel = acquiringChannel;
            return this;
        }
        
        /**
         * Set attachment
         * @param attachment  (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder attachment(Attachment attachment) {
            this.attachment = attachment;
            return this;
        }
        
        /**
         * Set authorizationToken
         * @param authorizationToken Authorization token. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder authorizationToken(String authorizationToken) {
            this.authorizationToken = authorizationToken;
            return this;
        }
        
        /**
         * Set billingAddress
         * @param billingAddress  (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder billingAddress(Address billingAddress) {
            this.billingAddress = billingAddress;
            return this;
        }
        
        /**
         * Set clientToken
         * @param clientToken Token to be passed to the JS client (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder clientToken(String clientToken) {
            this.clientToken = clientToken;
            return this;
        }
        
        /**
         * Set customPaymentMethodIds
         * @param customPaymentMethodIds Promo codes - The array could be used to define which of the configured payment options within a payment category (pay_later, pay_over_time, etc.) should be shown for this purchase. Discuss with the delivery manager to know about the promo codes that will be configured for your account. The feature could also be used to provide promotional offers to specific customers (eg: 0% financing). Please be informed that the usage of this feature can have commercial implications.  (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder customPaymentMethodIds(List<String> customPaymentMethodIds) {
            this.customPaymentMethodIds = customPaymentMethodIds;
            return this;
        }
        
        /**
         * Set customer
         * @param customer  (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder customer(Customer customer) {
            this.customer = customer;
            return this;
        }
        
        /**
         * Set design
         * @param design Design package to use in the session. This can only by used if a custom design has been implemented for Klarna Payments and agreed upon in the agreement. It might have a financial impact. Delivery manager will provide the value for the parameter. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder design(String design) {
            this.design = design;
            return this;
        }
        
        /**
         * Set expiresAt
         * @param expiresAt Session expiration date (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder expiresAt(OffsetDateTime expiresAt) {
            this.expiresAt = expiresAt;
            return this;
        }
        
        /**
         * Set locale
         * @param locale Used to define the language and region of the customer. The locale follows the format of [RFC 1766](https://datatracker.ietf.org/doc/rfc1766/), meaning its value consists of language-country. Read more on **[Supported Locals and Currencies](https://docs.klarna.com/klarna-payments/in-depth-knowledge/puchase-countries-currencies-locales/)**. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder locale(String locale) {
            this.locale = locale;
            return this;
        }
        
        /**
         * Set merchantData
         * @param merchantData Pass through field to send any information about the order to be used later for reference while retrieving the order details (max 6000 characters) (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder merchantData(String merchantData) {
            this.merchantData = merchantData;
            return this;
        }
        
        /**
         * Set merchantReference1
         * @param merchantReference1 Used for storing merchant&#39;s internal order number or other reference. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder merchantReference1(String merchantReference1) {
            this.merchantReference1 = merchantReference1;
            return this;
        }
        
        /**
         * Set merchantReference2
         * @param merchantReference2 Used for storing merchant&#39;s internal order number or other reference. The value is available in the settlement files. (max 255 characters). (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder merchantReference2(String merchantReference2) {
            this.merchantReference2 = merchantReference2;
            return this;
        }
        
        /**
         * Set merchantUrls
         * @param merchantUrls  (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder merchantUrls(MerchantUrls merchantUrls) {
            this.merchantUrls = merchantUrls;
            return this;
        }
        
        /**
         * Set options
         * @param options  (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder options(Options options) {
            this.options = options;
            return this;
        }
        
        /**
         * Set orderAmount
         * @param orderAmount Total amount of the order including tax and any available discounts. The value should be in non-negative minor units. Eg: 25 Euros should be 2500. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder orderAmount(Long orderAmount) {
            this.orderAmount = orderAmount;
            return this;
        }
        
        /**
         * Set orderLines
         * @param orderLines The array containing list of line items that are part of this order. Maximum of 1000 line items could be processed in a single order. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder orderLines(List<OrderLine> orderLines) {
            this.orderLines = orderLines;
            return this;
        }
        
        /**
         * Set orderTaxAmount
         * @param orderTaxAmount Total tax amount of the order. The value should be in non-negative minor units. Eg: 25 Euros should be 2500. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder orderTaxAmount(Long orderTaxAmount) {
            this.orderTaxAmount = orderTaxAmount;
            return this;
        }
        
        /**
         * Set paymentMethodCategories
         * @param paymentMethodCategories Available payment method categories (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder paymentMethodCategories(Set<PaymentMethodCategory> paymentMethodCategories) {
            this.paymentMethodCategories = paymentMethodCategories;
            return this;
        }
        
        /**
         * Set purchaseCountry
         * @param purchaseCountry The purchase country of the customer. The billing country always overrides purchase country if the values are different. Formatted according to ISO 3166 alpha-2 standard, e.g. GB, SE, DE, US, etc. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder purchaseCountry(String purchaseCountry) {
            this.purchaseCountry = purchaseCountry;
            return this;
        }
        
        /**
         * Set purchaseCurrency
         * @param purchaseCurrency The purchase currency of the order. Formatted according to ISO 4217 standard, e.g. USD, EUR, SEK, GBP, etc. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder purchaseCurrency(String purchaseCurrency) {
            this.purchaseCurrency = purchaseCurrency;
            return this;
        }
        
        /**
         * Set shippingAddress
         * @param shippingAddress  (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder shippingAddress(Address shippingAddress) {
            this.shippingAddress = shippingAddress;
            return this;
        }
        
        /**
         * Set status
         * @param status The current status of the session. Possible values: &#39;complete&#39;, &#39;incomplete&#39; where &#39;complete&#39; is set when the order has been placed. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder status(String status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set intent
         * @param intent Intent for the session. The field is designed to let partners inform Klarna of the purpose of the customer’s session. (optional)
         * @return UpdateSessionDetailsRequestBuilder
         */
        public UpdateSessionDetailsRequestBuilder intent(String intent) {
            this.intent = intent;
            return this;
        }
        
        /**
         * Build call for updateSessionDetails
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The session was updated successfully. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to update the session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Session session = buildBodyParams();
            return updateSessionDetailsCall(sessionId, session, _callback);
        }

        private Session buildBodyParams() {
            Session session = new Session();
            if (this.acquiringChannel != null)
            session.acquiringChannel(Session.AcquiringChannelEnum.fromValue(this.acquiringChannel));
            session.attachment(this.attachment);
            session.authorizationToken(this.authorizationToken);
            session.billingAddress(this.billingAddress);
            session.clientToken(this.clientToken);
            session.customPaymentMethodIds(this.customPaymentMethodIds);
            session.customer(this.customer);
            session.design(this.design);
            session.expiresAt(this.expiresAt);
            session.locale(this.locale);
            session.merchantData(this.merchantData);
            session.merchantReference1(this.merchantReference1);
            session.merchantReference2(this.merchantReference2);
            session.merchantUrls(this.merchantUrls);
            session.options(this.options);
            session.orderAmount(this.orderAmount);
            session.orderLines(this.orderLines);
            session.orderTaxAmount(this.orderTaxAmount);
            session.paymentMethodCategories(this.paymentMethodCategories);
            session.purchaseCountry(this.purchaseCountry);
            session.purchaseCurrency(this.purchaseCurrency);
            session.shippingAddress(this.shippingAddress);
            if (this.status != null)
            session.status(Session.StatusEnum.fromValue(this.status));
            if (this.intent != null)
            session.intent(Session.IntentEnum.fromValue(this.intent));
            return session;
        }

        /**
         * Execute updateSessionDetails request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The session was updated successfully. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to update the session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            Session session = buildBodyParams();
            updateSessionDetailsWithHttpInfo(sessionId, session);
        }

        /**
         * Execute updateSessionDetails request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The session was updated successfully. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to update the session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            Session session = buildBodyParams();
            return updateSessionDetailsWithHttpInfo(sessionId, session);
        }

        /**
         * Execute updateSessionDetails request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The session was updated successfully. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> We were unable to update the session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            Session session = buildBodyParams();
            return updateSessionDetailsAsync(sessionId, session, _callback);
        }
    }

    /**
     * Update a session
     * Use this API call to update a Klarna Payments session with new details, in case something in the order has changed and the checkout has been reloaded. Including if the consumer adds a new item to the cart or if consumer details are updated. Read more on **[Update an existing payment session](https://docs.klarna.com/klarna-payments/other-actions/update-the-cart/)**.
     * @param sessionId session_id (required)
     * @param session session_request (required)
     * @return UpdateSessionDetailsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The session was updated successfully. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> We were unable to update the session with the provided data. Some field constraint was violated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You were not authorized to execute this operation. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The session does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public UpdateSessionDetailsRequestBuilder updateSessionDetails(String sessionId) throws IllegalArgumentException {
        if (sessionId == null) throw new IllegalArgumentException("\"sessionId\" is required but got null");
            

        return new UpdateSessionDetailsRequestBuilder(sessionId);
    }
}
